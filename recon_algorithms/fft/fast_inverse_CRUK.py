#----------------------------------------
#
#      fast_inverse
#
#      L. Kunyansky
#      University of Arizona
#      December 2021
#
#   This program computes a thermoacoustic inversion from the
#   data given on a time/space cylinder.
#   The algorithm is fast i.e. roughly speaking  O(n^2 log n) flops for
#   ( O(n) x O(n)) data and (n x n) image.
#
#   The program implements both a traditional reconstruction, and the
#   microlocally accurate partial data reconstruction
#   see
#      M. Eller, P. Hoskins, and L. Kunyansky
#      Microlocally accurate solution of the inverse source problem
#      of thermoacoustic tomography Inverse Problems 36(8), 2020, 094004
#
#   The data for the program are given in three files:
#
#   (1) "inverse.cfg" contains rows with
#        the name of data file with the data
#        the dimension ndim of the image to reconstruct (ndim = an even FFT-friendly number + 1) , for example 257
#        an integer zero padding coefficient, equal 1, 2, or 4  (1 is least accurate, 2 is recommended, 4 is most accurate and slowest)
#        wave killing parameter (0 = stndard reconstruction, 1 or 2 means the upper or lower half of spatial frequencies is removed)
#
#   (2) "geom.cfg", automatically generated by the direct programs, containing
#        the number of detectors equispaced on the circle (an even FFT-friendly number, e.g. 512 or 1024)
#        the number of times steps ( an even FFT-friendly number +1, e.g. 769 0r 1025), with first step at t=0 and last step t= tmax
#        the time length of the data, assuming the speed of sound is equal to 1
#        the radius of the circles with detectors, at the moment should be equal 1. only
#
#   (3)  the data file whose name is given on the first line of "inverse.cfg"
#        it should have data in the proprietory (but really simple .d format:
#        it is a rectangular array of mostly 4-bite single precision real (or float) numbers,
#        with the exception of the first line that gives the dimensions of the rectangles.
#        See ndwrite and ndread routines in "uitls.py"
#        The data array in itself (after the header) represents the number-of-time-steps rows
#        each with number-of-detectors real numbers representing "measurements"
#-----------------------------------------------------------------------------------------------

import sys
sys.path.append('..\modules')
import numpy as np
import scipy as sp
import math
import time
import os
from scipy.interpolate import RectBivariateSpline

from utils import ndread
from utils import ndwrite
from utils import npyread
#from mymath import my_bilinear_intrp
#from mymath import my_quadrature
from mymath import t6hat

#--------- define polar coordinate transformation, readgeom, readinverse and prepare_hankels routines

def cart_to_polar_coor(xx,yy):               #------------------------- begin cart_to_polar
   rad = np.sqrt( xx*xx + yy*yy  )
   angle = np.arccos(xx/(rad+1.e-300))
   angle[yy < 0.] = 2.* math.pi - angle[yy < 0.]

   return rad,angle                          #------------------------- end cart_to_polar


def readgeom(namegeom):   #------------------------------------------ begin readgeom

 print('--- Reading file ',namegeom,':')

 with open(namegeom,'r') as ffile:

    sss = ffile.readline()
    ndet =  int(sss[0:4])
    print(ndet,end='')
    print(sss[5:],end='')

    sss = ffile.readline()
    ntimes =  int(sss[0:4])
    print(ntimes,end='')
    print(sss[5:],end='')

    sss = ffile.readline()
    tmax =  float(sss[0:5])
    print('{:4.3f}'.format(tmax),end='')
    print(sss[6:],end='')

    sss = ffile.readline()
    raddet =  float(sss[0:5])
    print('{:4.3f}'.format(raddet),end='')
    print(sss[6:],end='')


 ffile.close()

 print('')

 return ndet,ntimes,tmax,raddet   #------------------------------------ end readgeom



def readinverse(nameconfig):    #-------------------------------------- begin readconfig
 print('--- Reading file ',nameconfig,':')

 with open(nameconfig,'r') as ffile:

    #sss = ffile.readline()
    #namedata = sss[0:20]
    #print(namedata,end='')
    #print(sss[21:],end='')

    sss = ffile.readline()
    ndim = int(sss[0:4])
    print(ndim,end='')
    print(sss[5:],end='')

    sss = ffile.readline()
    ndimimage = int(sss[0:4])
    print(ndimimage,end='')
    print(sss[5:],end='')

    sss = ffile.readline()
    l = int(sss[0:1])
    print(l,end='')
    print(sss[2:],end='')

    sss = ffile.readline()
    lhalf =  int(sss[0:1])
    print(lhalf,end='')
    print(sss[2:],end='')

#    sss = ffile.readline()
#    iwrite =  int(sss[0:1])
#    print(ntimes,end='')
#    print(sss[2:],end='')

 ffile.close()

 print('')

 return ndim, ndimimage, l, lhalf   #--------------------------- end readconfig


def prepare_hankels(ndet,freq_rad):     #---------------------- begin prepare_hankels

   midk = round(ndet/2)


   ind_grid  = np.array(range(midk))

   indices, frequencies = np.meshgrid( ind_grid, freq_rad  )

   hank_temp = sp.special.hankel1(indices, frequencies)*frequencies

   large_number = 1.e+30

   hank_temp[ np.isnan(hank_temp)] = large_number
   hank_temp[ abs(hank_temp) > large_number ] = large_number

   hank_flip = hank_temp[:, ::-1 ]


   hankels = np.zeros((numfreq,ndet), dtype='complex')

   hankels[1:, midk: ]  = np.copy(hank_temp)
   hankels[1:, 1:midk] = np.copy(hank_flip[:,0:midk-1])

   hankels[0,:]  =   large_number
   hankels[:,0] = large_number

   return hankels                                #--------------------- end prepare hankels

def process_real_data(fullnamedata):

   pt=np.load(fullnamedata)
   data_shape = np.shape(pt)

   ndet_exist = data_shape[0]
   nsamples_exist = data_shape[1]

   print('Data dimensions: ',ndet_exist,nsamples_exist)

   nsamples = 3*1024+1
   late_cut_start = nsamples_exist-500
   late_cut_end = nsamples_exist - 100

   early_cut_end  = 700
   early_cut_start = 540

   t_radius = 0.0405/1489    #  radius in microseconds
   #print(t_radius)
   t_meas = (nsamples-1)/40000000
   #print(t_meas)
   tmax = t_meas/t_radius


   data = np.zeros((ndet_exist,nsamples))

   xxx = np.linspace(0.,nsamples-1,nsamples)

   hat0 = t6hat(late_cut_end,late_cut_start,xxx)
   hat1 = 1.-t6hat(early_cut_end,early_cut_start,xxx)

   for k in range(ndet_exist):
       onerow = pt[k,:]
       onerow[0:40]=0
       average = np.mean(onerow[40:])
       onerow[40:] = onerow[40:] - average
       data[k,0:nsamples_exist] = onerow
       data[k,:] = data[k,:]*hat0*hat1


   det_step =  270./(ndet_exist-1)
   ndet = round(360./det_step)
   print('ndet = ',ndet)
   added =ndet -ndet_exist
   print('added det positions = ',added)

   datanew = np.zeros((ndet,nsamples))
   datanew[:ndet_exist,:] = data

   datanew = np.roll(datanew,-round(added/2) -85,0)

   ndwrite(datanew,'mydata.d')
   ndwrite(np.transpose(datanew),'cylinder.d')
   #
   #rad = 1.
   #
   #with open('geomcirc.cfg','w') as f:
   #    f.write('{0:4d}'.format(ndet)    +'                                             ndet \n')
   #    f.write('{0:4d}'.format(nsamples)  +'                                          ntimes \n ')
   #    f.write('{:4.3f}'.format(tmax)   +'                                          tmax \n')
   #    f.write('{:3.1f}'.format(rad)    +'                                          raddet \n')
   #
   #f.close()

   return nsamples,ndet,np.transpose(datanew)     #  ndet <-> nsamples    !!!!






#-----------------------------------------------------------------------------------------------------
#  Main program starts here
#-----------------------------------------------------------------------------------------------------


print(' ')
print('*****************')
print('Fast_inverse_CRUK')
print('*****************')
print(' ')


#---------------------------- analyze input parameters ---------------------------------------

arguments = len(sys.argv) - 1
if(arguments not in [1, 2,3]):
    print("nunber of arguments is ",arguments," WTF ???")
    exit()

if(arguments >= 1):
   fullnamedata =sys.argv[1]
   (path_and_name_data,data_extension) = os.path.splitext(fullnamedata)


#---------------------------- read configs ---------------------------------------------------

ndet,ntimes,tmax,raddet =       readgeom   ('geomCRUK.cfg')

ndim, ndimimage, l,lhalf  =            readinverse('inverseCRUK.cfg')


#---------------------------- read data ------------------------------------------------------

if(data_extension == '.npy'):
   nrow,ncol,data = process_real_data(fullnamedata)
else:
   data,nrow,ncol = ndread(fullnamedata)

print (nrow,ncol)

if (nrow != ntimes):
    print('Wrong times !')
    quit()

if (ncol != ndet):
    print('Wrong number of detectors !')
    quit()

print('--- File ',fullnamedata,'--- was read.')
print(' ')
print('---------- time to start! -------------------')
print(' ')

#--------------------------- define the geometry and the timing of the problem ---------------
start_time = time.time()

if (l!=1):                                #------- additional zero-padding if requested
    newtimes = (ntimes-1)*l +1
    datanew = np.zeros((newtimes,ndet))
    datanew[0:ntimes,:] = np.copy(data)
    data = datanew
    ntimes = newtimes
    tmax = l*tmax

halfsize = 1.0                     #------------- reconstructed image geometry
med = round((ndim+1))

spatial_freq_step = 2.0*math.pi/(2.*halfsize)             #------- image 2D Fourier transform geometry
spatial_freq_max =  spatial_freq_step * (ndim-1)/2


det_angle_ext = np.linspace(0.,2*math.pi,ndet+1)    #---------- detector geometry
det_angle = np.copy(det_angle_ext[0:ndet])


times = np.linspace(0.,tmax,ntimes)            #-------------- time grid
tstep = times[1]-times[0]

nfft_points = ntimes -1                        #------------- time Fourier transform geometry
freqstep = 2.0*math.pi/tmax
ldrad = nfft_points
numfreq = round(nfft_points/2)
time_freq_scale = freqstep*np.array(range(numfreq))

freq_rad  = time_freq_scale[1:]        # intentionally skiping zero frequency

#-------------------------- prepare Hankel functions -------------------------------------

hankels = prepare_hankels(ndet,freq_rad)

hankel_time = time.time()
print('Preparing Hankel functions','{:05.2f}'.format(hankel_time - start_time),' sec')


#----------------------- make a smooth cut of the input data ------------------------
tcut = 0.9*tmax
hat = t6hat(tmax/l,tcut/l,times)
hat = hat[0:nfft_points]

cdata = np.zeros((nfft_points,ndet), dtype='complex')

for j in range(ndet):
   cdata[:,j] = np.copy(data[0:nfft_points,j])*hat


#----------------------- fft in time and in angle ----

ctemp_fourier =  sp.fft.fftshift( sp.fft.ifft2(cdata), [1])
cfourier = ctemp_fourier[0:numfreq]

time_fft = time.time()
print('FFT data in time and angle  ','{:05.2f}'.format(time_fft - hankel_time),' sec')

#--------------------------- multiplying by (-i)^k ---------------------------------------
midk = round(ndet/2)

for kk in range(ndet):
   k = abs(kk-midk)
   coef = ( -1j )**k
   cfourier[:,kk] = cfourier[:,kk]/coef    # divide or multiply ?


#----------------------------- divide Fourier transform by Hankels --------------------------------

cfourier_new = cfourier/hankels

#------------------------------------ Finding the DC number by integrating the zero harmonics -----

czero_harm = np.copy(cfourier_new[:,midk])

j1 =  np.real(hankels[:,midk+1])
csum = np.sum(czero_harm[1:]*j1[1:]/freq_rad)*freqstep  # *2/math.pi

#----------------------------- inverse Fourier transform in angle ---------------------------------

ctran =  sp.fft.fft(   sp.fft.fftshift( cfourier_new, [1]),axis = 1)

ctran[0,:] = np.real(csum)           #---- using the DC number computed above

time_fft = time.time()
print('Inverse Fourier in angle','{:05.2f}'.format(time_fft - hankel_time ),' sec')

#------------------------ interpolate from the polar grid to Cartesian in the Fourier domain ------


freq_scale =  np.linspace(-spatial_freq_max,spatial_freq_max,ndim)
ksi1, ksi2 = np.meshgrid(freq_scale,freq_scale)


freq_rho,freq_teta = cart_to_polar_coor(ksi1,ksi2)

ctran_ext = np.zeros((numfreq,ndet+1), dtype= 'complex')
ctran_ext[:,0:ndet] = np.copy(ctran)
ctran_ext[:,ndet] = np.copy(ctran_ext[:,0])


start_spline_time = time.time()

interp_spline_r = RectBivariateSpline(time_freq_scale,det_angle_ext,np.real(ctran_ext),kx=3,ky=3)
interp_spline_i = RectBivariateSpline(time_freq_scale,det_angle_ext,np.imag(ctran_ext),kx=3,ky=3)

cart_transform = interp_spline_r.ev(freq_rho,freq_teta) + 1j * interp_spline_i.ev(freq_rho,freq_teta)

spline_time = time.time()

print('Interpolation to Cartesian grid ','{:05.2f}'.format(spline_time - start_spline_time),' sec')
#------------------------- cut off redundant frequencies -------------------------------------------
mcenter = round((ndim-1)/2)
if(lhalf == 1):
   cart_transform[0:mcenter,:] = np.conj(np.copy(np.flip(cart_transform[mcenter+1:,:],[0,1])))
if(lhalf == 2):
   cart_transform[mcenter+1:,:] = np.conj(np.copy(np.flip(cart_transform[0:mcenter,:],[0,1])))
if(lhalf == 3):
   cart_transform[:,0:mcenter] = np.conj(np.copy(np.flip(cart_transform[:,mcenter+1:],[0,1])))
if(lhalf == 4):
   cart_transform[:,mcenter+1:] = np.conj(np.copy(np.flip(cart_transform[:,0:mcenter],[0,1])))


#------------------------- inverse 2D Fourier transform to obtain the image ------------------------
coefficient = tmax  # ------ why?

image =  coefficient* np.real( sp.fft.fftshift( sp.fft.fft2(   sp.fft.fftshift( cart_transform[0:ndim-1,0:ndim-1], [0,1])), [0,1] )   )
image_ext = np.zeros((ndim,ndim))
image_ext[0:ndim-1,0:ndim-1] = image

fft_time = time.time()

print('2D inverse FFT ','{:05.2f}'.format(fft_time - spline_time),' sec')

#-------------------------- additional correction for zero boundary conditions ----------------------

xx = np.linspace(-halfsize,halfsize,ndim)
xstep = xx[1]-xx[0]
xxx,yyy = np.meshgrid(xx,xx)
rad = np.sqrt(xxx*xxx+yyy*yyy)

aaa = np.zeros((ndim,ndim))
aaa[rad > 1.0] = 1.
aaa[rad > 1.0 + 2.*xstep] = 0.

number_of_pixels = np.sum(aaa)
average  = np.sum(aaa*image_ext)/number_of_pixels

image_ext = image_ext - average
print('average = ', average)

image_ext[rad >= 1.] = 0.      # set to 0 outside of the unit circle

ioffset = round((ndim-ndimimage)/2)
print(ioffset)
imagesmall = np.copy(image_ext[ioffset:ioffset+ndimimage,ioffset:ioffset+ndimimage])

#-------------------------------- done --------------------------------------------------------------

final_time = time.time()

print('Total time ','{:05.2f}'.format(final_time - start_time),' sec')

if(arguments >= 2):
   name_small_npy =sys.argv[2]
   #(path_and_name_data,data_extension) = os.path.splitext(fullnamedata)
else:
   name_small_npy = 'small.npy'

if(arguments == 3):
   dir = sys.argv[3]
   if(not os.path.exists(dir)):
        os.mkdir(dir)
   name_small_npy = dir + "\\"+name_small_npy

np.save(name_small_npy,imagesmall)

ndwrite(imagesmall,'small_inv.d')
ndwrite(image_ext,'fast_inv.d')











quit()

